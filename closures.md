
> 	Что такое замыкание в JavaScript?

---
### Предисловие
При создании функции в JavaScript внутри неё инициализируется объект окружения данных, так называемый `LexicalEnvironment`, содержащий в себе помимо всех переменных используемых внутри функции ссылку на родительское окружение (частным случаем родительского окружения для функций определённых в глобальном пространстве является объект `window`). По окончании работы функции если никакая из переменных не используется - объект окружения удаляется.

Также JavaScript позволяет создавать вложенные функции в ходе исполнения скрипта. Если мы создаём новую функцию внутри существующей родительской функции то через ссылку на окружение родительской функции ей будут доступны как свои локальные переменные так и все переменные и функции объявленные в родительской функции, пример:

    function increaser() {
    	var  foo = 0;
    
    	function plusOne() {
    		return ++foo;
    	}
    
    	return plusOne;
    }
    
    var a = increaser();
    a(); // 1
    a(); // 2
    a(); // 3
    a(); // 4
    ...


После выполнения функции increaser её окружение и все относящиеся к нему свойства и методы остаются доступными через ссылку во внутреннем окружении дочерней функции plusOne, таким образом функция `plusOne` своим существованием замыкает на себя окружение переменных родительской функии `increaser`.

### Определение
`Замыкание` — это функция со всеми доступными ей переменными и методами внешнего окружения.


### Практические примеры использования
С помощью замыканий к примеру можно довольно изящно решить другое тестовое задание компании Яндекс:
> Мы уделяем большое внимание производительности наших приложений. Нередко случается, что отдельно взятая функция (например, обработчик события) работает достаточно долго, а вызывается часто, что сильно ухудшает отзывчивость интерфейса. 
Предложите общее решение, позволяющее вызывать любую функцию не чаще N раз в секунду, даже если её вызов происходит чаще.

Решение:

    function setIntervalLimit(fn, psInterval) {
    	// Переменная в которой будет храниться ID таймаута
    	var timeoutLock = null;

    	// Функция для снятия блокировки по тамймауту
    	var unlock = function() {
    		clearTimeout(timeoutLock);
    		timeoutLock = null;
    	}

    	// Создаём функцию обёртку в которой будем проверять интервал вызова 
    	var wrapFunction = function() {
    		// Если не истёк тамймаут после предыдущего запуска функции
    		if (timeoutLock) {
    			// Выводим отладочное сообщение
    			if (console) { console.log('Not so fast, buddy! :-)'); }
    			// ...и выходим из функции
    			return;
    		}
    		
    		// Запускаем таймаут по истечении которого функция вновь сможет быть вызвана
    		timeoutLock = setTimeout(unlock, 1000 / (psInterval || 1));
    		
    		// Пробрасываем наверх результат работы исходной функции с переданными аргументами
    		return fn.apply(this, arguments);
    	}
    	
    	// Возвращаем функцию-"обёртку"
    	return wrapFunction;
    }
    
    // Применяем наше решение
    
    // Установим функции округления вызов не чаще 2 раз в секунду
    Math.round = setIntervalLimit(Math.round, 2);
    
    // Проверяем
    console.log(Math.round(3.14159265358979323846264338327)); // 3
    setTimeout(function() { console.log(Math.round(3.14159265358979323846264338327)); }, 250); // Not so fast, buddy! :-)
    setTimeout(function() { console.log(Math.round(3.14159265358979323846264338327)); }, 500); // 3
    setTimeout(function() { console.log(Math.round(3.14159265358979323846264338327)); }, 750); // Not so fast, buddy! :-)